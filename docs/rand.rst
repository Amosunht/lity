================================================================
Rand - Get random number on the chain
================================================================

.. _rand:


.. WARNING::
   Lity supports built-in random function after lity v1.2.7.



Built-in Random Function
------------------------

Lity provides a new built-in function `rand` for the gaming Dapp developers.

The function prototype is `function rand() returns (uint)`. When calling `rand()`, developers will receive an random number which is generated by the following formula:

.. code-block:: Lity

  function rand() returns (uint) {
    return keccak256(Randomness Seed, Nonce, CodeHash, Counter);
  }


- The `Randomness Seed` is generated by Travis chain and you can find it in the difficulty field of current block header.

- The `Nonce` is nonce of the transaction origin and depends on the transaction order in current block.

- The `CodeHash` is the hash of caller's contract bytecode

- The `Counter` will automaticlly increase after the `opRand` is called.


The developers should be aware of the usage of random number.

1. `Randomness Seed` depends on current block. It will be the same until receiving the next block.

2. `Nonce` depends on the transaction order. When you test in local environment and don't produce a new transaction, you might get the same nonce.

3. `CodeHash` will not change after you deployed the contract.

4. `Counter` depends on the the called time of rand(). If you call `rand()` twice in same code block, you will receive different results.

Example 1
---------

.. code-block:: Lity

  pragma lity ^1.2.7;

  contract RandNumberExample {
    uint randnum;
    function getAndSetRandnum() public returns (uint) {
      randnum = rand();
      return randnum;
    }
  }

**Note** You should NOT call `rand()` in a `view` or `pure` function. If the random number does not need to be recorded on the blockchain (i.e., outside of a transaction in a `view` function executed on a single node), it does not need to be generated by the blockchain. The calling application should simply generate a random number locally -- it is much cheaper in terms of resource consumption.

